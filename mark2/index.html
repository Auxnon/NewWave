<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		body{
			background-color: black;
			overflow: hidden;
			touch-action:none;
		}
		.app{
			position: absolute;
			background-color: #4158D0;
			background-image: linear-gradient(156deg, #4158D0 0%, #C850C0 46%, #FFCC70 100%);
			border-radius:  16px;
			width: 128px;
			height: 128px;
			left: 128px;
			top: 128px;
			transform: translate(-50%,-50%);
			transition: 0.4s;
			z-index: 1;
		}
		.appMove{
			border-top: 6px white solid;
			transition: border-radius 0.4s, width 0.4s, height 0.4s;
		}
		#bar{
			position: absolute;
			width: 256px;
			height: 128px;
			border-radius: 32px;
			border: white 3px solid;
			background-color: #4444;
			transform: translate(-50%,-50%);
			left: 50%;
			bottom: 64px;
		}
		#barHandle{
			width: 80%;
			height: 64px;
			border-radius: 32px;
			border: white solid 3px;
			position: absolute;
			top:50%;
			left: 50%;
			transform: translate(-50%,-200%);
		}
		.appMax{
			width: 100%;
			height: 100%;
			border-radius: 0px;
			top: 50% !important;
			left: 50% !important;
		}
		#two{
			background-color: #FAD961;
			background-image: linear-gradient(90deg, #FAD961 0%, #F76B1C 100%);
			left: 256px;
			top: 264px;
		}
		#thr{
			background-color: #FA8BFF;
			background-image: linear-gradient(45deg, #FA8BFF 0%, #2BD2FF 52%, #2BFF88 90%);
			left: 356px;
			top: 34px;
		}
		svg{
			position: absolute;
			left: 0;
			top: 0;
			margin:0;
			pointer-events: none;
		}


	</style>
</head>
<body>
	<div id="bar">
		<div id="barHandle"></div>
	</div>
	<div class="app" id="one"></div>
	<div class="app" id="two"></div>
	<div class="app" id="thr"></div>
	<svg stroke="white" fill="none" stroke-width="6" stroke-linecap="round">
		<path d="M0 0 L 100 100"/>	
	</svg>
</body>
<script>
	var focused;
	var apps;
	var svg;
	var path;
	var bar;
	var appPoints;
	var moveFactor=0;
	function init(argument) {
		let preApps=document.querySelectorAll('.app');
		apps=[]
		preApps.forEach(app=>{ //convert out of a nodelist to an array, it matters trust me
			apps.push(app)
		});
		apps.forEach((app,index)=>{
			app.style.top=Math.random()*512+'px'
			app.style.left=Math.random()*512+'px'
			app.addEventListener('click',ev=>{
				
			})
			app.origin={x:0,y:0};
			app.offset={x:0,y:0};
			//app.addEventListener('mousedown',ev=>{appMouseDown(app,ev);})
			app.addEventListener('pointerdown',ev=>{appMouseDown(app,ev);})
		});
		window.addEventListener('pointerup',winMouseUp)
		/*setInterval(()=>{
			apps.forEach(app=>{
				app.style.top=parseInt(app.style.top)+rand()+'px'
				app.style.left=parseInt(app.style.left)+rand()+'px'
				
			})
		},1000);*/
		path=document.querySelector('path')
		svg=document.querySelector('svg')
		resize();
		window.addEventListener('resize', resize);
		initLine();
		window.addEventListener('pointermove',mousemove)
		window.addEventListener('click',click)

		mouseObj={x:0,y:0}
		
		barInit();
		animate();
		setInterval(()=>{boundaryCheck()},3000)
		
	}init();
	function resize(){
		svg.setAttribute('width',window.innerWidth+"px")
		svg.setAttribute('height',window.innerHeight+"px")
	}
	function rand(){
		return Math.random()*100 -50;
	}
	//var mousePrev={x:0,y:0}
	var mouseObj;
	var points
	function initLine(){
		points=[];
		for(let i=0;i<10;i++){
			points.push({x:0,y:0});
		}
	}
	var count=0;
	var tick=false;
	var lastDir=false
	var mouseToggle=0;
	var targetMove=undefined;
	var targetPoint={x:0,y:0}

	function click(){
		if(mouseToggle>0)
			mouseToggle=0;
		else
			mouseToggle=1;
	}
	var barMove=false;
	function barInit(){
		bar=document.querySelector('#bar')
		let barHandle=document.querySelector('#barHandle')
		barHandle.addEventListener('pointerdown',ev=>{
			let xx=barBox.left+(barBox.right-barBox.left)/2
			let yy=barBox.top+(barBox.bottom-barBox.top)/2

			barMove={x:ev.clientX-xx,y:ev.clientY-yy};
		})
		barHandle.addEventListener('pointerup',ev=>{
			barMove=false;
		})


		barHandle.addEventListener('pointermove',ev=>{
			let xx=-barMove.x+ev.clientX;
			let yy=-barMove.y+ev.clientY
			if(window.innerWidth>window.innerHeight){ //landscape
				let half=(window.innerWidth - window.innerHeight)/2
				if(xx<half){ //left
					bar.style.transform='rotate(90deg)'
					barHandle.style.transform='translate(-50%,-200%)'
				}else if(xx>window.innerWidth-half){ //right
					bar.style.transform='rotate(90deg)'
					barHandle.style.transform='translate(-50%,100%)'
				}else{
					bar.style.transform='rotate(0deg)'
					if(yy>window.innerHeight/2){
						barHandle.style.transform='translate(-50%,-200%)'
					}else{
						barHandle.style.transform='translate(-50%,100%)'
					}
				}
			}else{ //portrait
				let half=(window.innerHeight - window.innerWidth)/2
				if(yy<half){ //top
					bar.style.transform='rotate(0deg)'
					barHandle.style.transform='translate(-50%,-200%)'
				}else if(yy>window.innerHeight-half){ //bottom
					bar.style.transform='rotate(0deg)'
					barHandle.style.transform='translate(-50%,100%)'
				}else{
					bar.style.transform='rotate(90deg)'
					if(xx>window.innerWidth/2){
						barHandle.style.transform='translate(-50%,-200%)'
					}else{
						barHandle.style.transform='translate(-50%,100%)'
					}
				}
			}
			
			bar.style.left=xx+'px'
			bar.style.top=yy+'px'
		})
		
		appPoints=[];
		
		barCalculate(true);
	}
	function barCalculate(notate){

		//first determine  how many apps will be visably part of the app bar
		let count=0;
		let appsInRow=[];
		if(!notate){
			apps.forEach(app=>{
				if(app.spot!=-1){
					appsInRow.push(app)
					count++;
				}
			})
		}else{
			count=apps.length;
			appsInRow=apps;
		}
		
		bar.style.width=(count>0?count:1)*128+'px'

		let rect = bar.getBoundingClientRect();
		barBox=rect
		console.log(rect.top, rect.right, rect.bottom, rect.left);
		let width=rect.right-rect.left;
		let height=rect.bottom-rect.top;
		let ratio=width/(count);

		if(!notate)
			appsInRow.sort(function(a, b) {
			  //sort by x, secondary by y
			  return parseInt(a.style.left) - parseInt(b.style.left);
			});
		
		for(let i=0;i<count;i++){
			appPoints[i]={x:64+rect.left+(i)*ratio,y:rect.top+height/2};

			
			if(targetMove && targetMove==appsInRow[i])
				targetPoint=appPoints[i]

			if(notate){
				apps[i].spot=i;
				appPoints[i].app=appsInRow[i]
			}
			_moveEle(appsInRow[i],appPoints[i].x,appPoints[i].y)
			
		}
	}
	function animate(){
			if(mouseToggle){
				let target={};
				switch(mouseToggle){
					case 2: target={x:100,y:200};break;
					case 3: target={x:100,y:600};break;
					default:target={x:100,y:100}
				}
				let dx=mouseObj.x-target.x;
				let dy=mouseObj.y-target.y;
				let dr=Math.sqrt(dx*dx +dy*dy)
				mouseObj.x-=dx/20
				mouseObj.y-=dy/20
				if(dr<1 && mouseToggle<3 )
					mouseToggle++;
			}

		
			let diff={x:mouseObj.x-points[0].x,y:mouseObj.y-points[0].y}
			let dr=Math.sqrt(diff.x*diff.x + diff.y*diff.y)

			if(dr>40){
				let fresh;
				if(mouseToggle>1){
					fresh={x:mouseObj.x,y:mouseObj.y};
				}else{
					fresh={x:mouseObj.x-(tick?1:-1)*20*diff.y/dr,y:mouseObj.y+(tick?1:-1)*20*diff.x/dr};
				}
				
				/*mouseObj.x-=(tick?1:-1)*20*diff.y/dr;
				mouseObj.y+=(tick?1:-1)*20*diff.x/dr;*/
				let dir=Math.abs(diff.x)>Math.abs(diff.y);
				let pos=dir?diff.x>0:diff.y>0
				/*if(dir!=lastDir)
					tick=!tick
				lastDir=dir*/
				tick=!tick

				let st="M"+mouseObj.x+" "+mouseObj.y;
				let last={x:fresh.x,y:fresh.y};
				for(let i=0;i<points.length;i++){
					let halfy=(points[i].y-last.y)/2
					let halfx=(points[i].x-last.x)/2
					let midx=last.x+halfx;
					let midy=last.y+halfy;
					st+="Q"+last.x+" "+last.y+" "+midx+" "+midy//+points[i].x+" "+points[i].y

					let prev={x:points[i].x,y:points[i].y};
					points[i]={x:last.x,y:last.y};
					last=prev;
				}
				path.setAttribute('d',st)
			}

			if(targetMove)
				moveFactor++;
		requestAnimationFrame(animate);
	}
	
	function mousemove(ev){
		if(targetMove){
			moveFactor++;
			targetMove.pos={x:ev.clientX+targetMove.offset.x,y:ev.clientY+targetMove.offset.y}
			/*let d={x:targetMove.origin.x-targetMove.pos.x,y:targetMove.origin.y-targetMove.pos.y}
			let dr=Math.sqrt(d.x*d.x +d.y*d.y);
			if(dr<80){
				targetMove.pos={x:targetMove.origin.x-d.x/3,y:targetMove.origin.y-d.y/3}
				if(targetMove.moving){
					targetMove.moving=undefined
					//targetMove.classList.remove('appMove')
				}
			}else{
				if(!targetMove.moving){
					targetMove.moving=true;
					//targetMove.classList.add('appMove')
				}
			}*/
			
			if(ev.clientY>barBox.top && ev.clientY<barBox.bottom && ev.clientX>barBox.left && ev.clientX<barBox.right){ //dev temp
					let point=targetPoint;
					let d={x:point.x-targetMove.pos.x,y:point.y-targetMove.pos.y}
					targetMove.pos={x:point.x-d.x/3,y:point.y-d.y/3}
					if(targetMove.moving){ //called once per state change
						targetMove.moving=undefined;
						targetMove.spot=0;
						barCalculate();
					}

					apps.forEach(app=>{
							if(app==targetMove || app.spot==-1){

							}else{
								if(app.pos.x>targetMove.pos.x){
									_moveEle(app,32+app.pos.x,app.pos.y,true)
								}else{
									_moveEle(app,-32+app.pos.x,app.pos.y,true)
								}
							}
						})						
				}else{
					if(!targetMove.moving){ //called once per state change
						targetMove.moving=true;
						targetMove.spot=-1;
						
						barCalculate()
					}
					
				}
			//appPoints.forEach(pointCheck)

			targetMove.style.left=targetMove.pos.x+'px'
			targetMove.style.top=targetMove.pos.y+'px'
		}else if(mouseToggle==0){
			if(count>2){
				count=0;
				/*let dd={x:mouseObj.x-ev.clientX,y:mouseObj.y-ev.clientY}
				mouseObj.x-=dd.x/20
				mouseObj.y-=dd.y/20*/
				mouseObj={x:ev.clientX,y:ev.clientY}
				
				

				//mousePrev=mouseObj;
			}count++
		}
	}
	function pointCheck(point,index){
		let d={x:point.x-targetMove.pos.x,y:point.y-targetMove.pos.y}
				let dr=Math.sqrt(d.x*d.x +d.y*d.y);


				if(dr<40){
					targetMove.pos={x:point.x-d.x/3,y:point.y-d.y/3}
					if(targetMove.moving){ //called once per state change
						targetMove.moving=undefined
						//targetMove.classList.remove('appMove')
					}
					if(point.app==targetMove){

					}else{ //switcheroo the app icons
						//let oldPoint=appPoints[targetMove.spot];
						let swapApp=point.app;
						targetMove.spot=index;
						apps.forEach(app=>{
							if(app==targetMove){

							}else{
								if(app.pos.x>targetMove.pos.x){
									_moveEle(app,64+app.pos.x,app.pos.y,true)
								}else{
									_moveEle(app,-64+app.pos.x,app.pos.y,true)
								}
							}

						})
						//_moveEle()

						//oldPoint.app=swapApp;
						//swapApp.pos.x=oldPoint.x; swapApp.pos.x=oldPoint.y;
						//_moveEle(swapApp,swapApp.pos.x,swapApp.pos.y);
						//swapApp.spot=targetMove.spot;


						//point.app=targetMove; targetMove.spot=index;


					}
				}else{
					if(!targetMove.moving){ //called once per state change
						targetMove.moving=true;
						//targetMove.classList.add('appMove')
						/*apps.forEach(app=>{
							_moveEle(app,app.pos.x,app.pos.y)
						});*/
					}
				}
	}

	function appMouseDown(app,ev){
		targetMove=app;
		app.pos={x:parseInt(app.style.left),y:parseInt(app.style.top)}
		app.origin={x:app.pos.x,y:app.pos.y}
		app.offset={x:app.pos.x-ev.clientX,y:app.pos.y-ev.clientY}
		app.classList.add('appMove')
		app.moving=undefined;
		moveFactor=0;
	}

	function winMouseUp(ev){
		if(targetMove){
			targetMove.classList.remove('appMove')
			if(moveFactor<20){
				if(focused && focused==targetMove){
						targetMove.classList.remove('appMax')
						focused=undefined;
						targetMove.style.zIndex=1;
				}else{
					targetMove.classList.add('appMax')
					if(focused){
						focused.classList.remove('appMax')
						focused.style.zIndex=1;
					}
					targetMove.style.zIndex=0;
					focused=targetMove;
				}
			}else{
				barCalculate();

				console.log('fix bar also' )
			}
		}else{
				barCalculate();
				console.log('fix bar')
			}
		targetMove=undefined;
	}

	function boundaryCheck() {
		apps.forEach(app=>{
			if(!app.focused){
				let rect=app.getBoundingClientRect();

				let x=rect.left;
				let y=rect.top;
				let w2=(rect.right-rect.left)/2;
				let h2=(rect.bottom-rect.top)/2

				if(x<0 ){
					app.style.left=w2+'px'
				}else if(x> window.innerWidth-w2*2){
					app.style.left=window.innerWidth-w2+'px'
				}
				if(y<0 ){
					app.style.top=h2+'px'
				}else if(y> window.innerHeight-h2*2){
					app.style.top=window.innerHeight-h2+'px'
				}

			}
			
		})
	}
	function _moveEle(ele,x,y,bool){
		if(!bool)
			ele.pos={x:x,y:y}
		ele.style.left=x+'px'
		ele.style.top=y+'px'
	}



	/**
	OlD curve code

	

				let last={x:mouseObj.x,y:mouseObj.y,dir:dir,pos:pos};
				let lastMode=-1;
				for(let i=0;i<points.length;i++){
					//st+="M"+last.x+" "+last.y
					let halfy=(points[i].y-last.y)/2
					let halfx=(points[i].x-last.x)/2
					if(lastMode==-1){
						lastMode=(Math.abs(halfx)<Math.abs(halfy))?1:0
					}
					if(points[i].dir==last.dir){
						if(!last.dir){ //up down dir //points[i].dir
							st+="Q"+last.x+" "+(last.y+halfy)+" "+(last.x+halfx)+" "+(last.y+halfy);
							st+="Q"+points[i].x+" "+(last.y+halfy)+" "+points[i].x+" "+points[i].y;
						}else{ //left right dir
							st+="Q"+(last.x+halfx)+" "+last.y+" "+(last.x+halfx)+" "+(last.y+halfy);
							st+="Q"+(last.x+halfx)+" "+points[i].y+" "+points[i].x+" "+points[i].y;
							
						}
					}else{ //curve in then
						if(last.dir){ // true is x left right
							if((halfy>0)!=last.pos){
								st+="C"+(last.x)+" "+(last.y-halfy)+" "+(last.x+halfx)+" "+(last.y-halfy)+" "+(last.x+halfx)+" "+(last.y+halfy);

								st+="Q"+(last.x+halfx)+" "+(last.y+halfy)+" "+points[i].x+" "+points[i].y;
														console.log('special')


							}else{
								st+="Q"+(points[i].x)+" "+last.y+" "+points[i].x+" "+points[i].y;
							}
							
						}else{
							st+="Q"+(last.x)+" "+points[i].y+" "+points[i].x+" "+points[i].y;
						}
					}
					
					

					


					let prev={x:points[i].x,y:points[i].y,dir:points[i].dir,pos:points[i].pos};
					points[i]={x:last.x,y:last.y,dir:last.dir,pos:last.pos};
					last=prev;
				}
	**/

</script>
</html>