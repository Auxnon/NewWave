<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		body{
			background-color: black;
			overflow: hidden;
			touch-action:none;
		}
		.app{
			position: absolute;
			background-color: #4158D0;
			background-image: linear-gradient(156deg, #4158D0 0%, #C850C0 46%, #FFCC70 100%);
			border-radius:  16px;
			width: 128px;
			height: 128px;
			left: 128px;
			top: 128px;
			transform: translate(-50%,-50%);
			transition: 0.4s;
			z-index: 1;
		}
		.appMove{
			border-top: 6px white solid;
			transition: border-radius 0.4s, width 0.4s, height 0.4s;
		}

		#bar{
			position: absolute;
			width: 256px;
			height: 128px;
			border-radius: 32px;
			/*border: white 3px solid;*/
			background-color: #4444;
			transform: translate(-50%,-50%);
			left: 50%;
			bottom: 64px;
			box-sizing: border-box;
		}
		#barHandle{
			width: 80%;
			height: 64px;
			border-radius: 32px;
			/*border: white solid 3px;*/
			position: absolute;
			top:50%;
			left: 50%;
			transform: translate(-50%,-200%);
		}
		.appMax{
			width: 100%;
			height: 100%;
			border-radius: 0px;
			top: 50% !important;
			left: 50% !important;
		}
		#two{
			background-color: #FAD961;
			background-image: linear-gradient(90deg, #FAD961 0%, #F76B1C 100%);
			left: 256px;
			top: 264px;
		}
		#thr{
			background-color: #FA8BFF;
			background-image: linear-gradient(45deg, #FA8BFF 0%, #2BD2FF 52%, #2BFF88 90%);
			left: 356px;
			top: 34px;
		}
		svg{
			position: absolute;
			left: 0;
			top: 0;
			margin:0;
			pointer-events: none;
		}

		#brightness{
			width: 56px;
			height: 56px;
			border-radius: 28px;
			position: absolute;
			top: 0;
			right: 0;
			background-repeat: no-repeat;
    		background-size:48px;
    		background-position: center center;

			
			background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="white"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M22.6 11.29L20 8.69V5c0-.55-.45-1-1-1h-3.69l-2.6-2.6c-.39-.39-1.02-.39-1.41 0L8.69 4H5c-.55 0-1 .45-1 1v3.69l-2.6 2.6c-.39.39-.39 1.02 0 1.41L4 15.3V19c0 .55.45 1 1 1h3.69l2.6 2.6c.39.39 1.02.39 1.41 0l2.6-2.6H19c.55 0 1-.45 1-1v-3.69l2.6-2.6c.39-.39.39-1.03 0-1.42zm-4.68 1.69c-.34 2.12-1.85 3.94-3.88 4.66-1.21.43-2.41.45-3.5.18-.41-.1-.48-.65-.13-.9C11.98 15.84 13 14.04 13 12s-1.02-3.84-2.58-4.92c-.35-.24-.29-.79.13-.9 1.09-.27 2.29-.25 3.5.18 2.02.72 3.54 2.54 3.88 4.66.05.33.07.66.07.98-.01.32-.03.65-.08.98z"/></svg>');
		}
		.brightnessDark{
			background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" ><path d="M0 0h24v24H0V0z" fill="none"/><path d="M20 15.31l2.6-2.6c.39-.39.39-1.02 0-1.41L20 8.69V5c0-.55-.45-1-1-1h-3.69l-2.6-2.6c-.39-.39-1.02-.39-1.41 0L8.69 4H5c-.55 0-1 .45-1 1v3.69l-2.6 2.6c-.39.39-.39 1.02 0 1.41L4 15.3V19c0 .55.45 1 1 1h3.69l2.6 2.6c.39.39 1.02.39 1.41 0l2.6-2.6H19c.55 0 1-.45 1-1v-3.69zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"/></svg>') !important;
		}


	</style>
</head>
<body>
	<div id="bar">
		<div id="barHandle"></div>
	</div>
	<div class="app" id="one"></div>
	<div class="app" id="two"></div>
	<div class="app" id="thr"></div>
	<svg stroke="white" fill="none" stroke-width="6" stroke-linecap="round">
		<path d="M0 0 L 100 100"/>	
	</svg>
	<div id="brightness"></div>
</body>
<script>
	var focused;
	var apps;
	var svg;
	var path;
	var bar;
	var barMove=-1;
	var barPos=1;
	var appPoints;
	var moveFactor=0;

	function init(argument) {
		let preApps=document.querySelectorAll('.app');
		apps=[]
		preApps.forEach(app=>{ //convert out of a nodelist to an array, it matters trust me
			apps.push(app)
		});
		apps.forEach((app,index)=>{
			app.style.top=Math.random()*512+'px'
			app.style.left=Math.random()*512+'px'
			app.addEventListener('click',ev=>{
				
			})
			app.origin={x:0,y:0};
			app.offset={x:0,y:0};
			//app.addEventListener('mousedown',ev=>{appMouseDown(app,ev);})
			app.addEventListener('pointerdown',ev=>{appMouseDown(app,ev);})
		});
		window.addEventListener('pointerup',winMouseUp)
		/*setInterval(()=>{
			apps.forEach(app=>{
				app.style.top=parseInt(app.style.top)+rand()+'px'
				app.style.left=parseInt(app.style.left)+rand()+'px'
				
			})
		},1000);*/
		path=document.querySelector('path')
		svg=document.querySelector('svg')
		resize();
		window.addEventListener('resize', resize);
		initLine();
		window.addEventListener('pointermove',mousemove)
		

		mouseObj={x:0,y:0}
		
		barInit();
		animate();
		setInterval(()=>{boundaryCheck()},3000)
		let brightness=document.querySelector('#brightness');
		brightness.addEventListener('click',ev=>{
			if(brightness.classList.contains('brightnessDark')){
				document.body.style.backgroundColor='black'
				svg.style.stroke='white'
			}else{
				document.body.style.backgroundColor='white'
				svg.style.stroke='black'
			}
			brightness.classList.toggle('brightnessDark')
		})	
		
	}init();
	function resize(){
		svg.setAttribute('width',window.innerWidth+"px")
		svg.setAttribute('height',window.innerHeight+"px")
	}
	function rand(){
		return Math.random()*100 -50;
	}
	//var mousePrev={x:0,y:0}
	var mouseObj;
	var points
	function initLine(){
		points=[];
		for(let i=0;i<10;i++){
			points.push({x:0,y:0});
		}
	}
	var count=0;
	var tick=false;
	var lastDir=false
	var barLineFactor=0;
	var targetMove=undefined;
	var targetPoint={x:0,y:0}

	
	function barInit(){
		bar=document.querySelector('#bar')
		let barHandle=document.querySelector('#barHandle')
		barHandle.addEventListener('pointerdown',ev=>{
			let xx=barBox.left//-(barBox.right-barBox.left)/2
			let yy=barBox.top//-(barBox.bottom-barBox.top)/2

			barMove=true;//{x:ev.clientX-xx,y:ev.clientY-yy};

			if(points.length<10){ //rebuild are point array
				let startPoint=points[0];
				let array=Array(7).fill(startPoint);
				points=array.concat(points)
			}

			barLineFactor= 0;
		})
		/*barHandle.addEventListener('pointerup',ev=>{
			barMove=false;
		})*/

		appPoints=[];
		
		barCalculate(true);
	}
	function barCalculate(notate){

		//first determine  how many apps will be visably part of the app bar
		let count=0;
		let appsInRow=[];
		let sideWays=barPos==0 || barPos==2;

		if(!notate){
			apps.forEach(app=>{
				if(app.spot!=-1){
					appsInRow.push(app)
					count++;
				}
			})
		}else{
			count=apps.length;
			appsInRow=apps;
		}
		if(sideWays){
			bar.style.height=(count>0?count:1)*128+'px'
			bar.style.width='128px'
		}else{
			bar.style.width=(count>0?count:1)*128+'px'
			bar.style.height='128px'
		}
		
		


		let rect = bar.getBoundingClientRect();
		barBox=rect
		let width=rect.width;
		let height=rect.height;

		let ratio;
		if(sideWays)
			ratio=height/(count);
		else
			ratio=width/(count);

		if(!notate){
			if(sideWays)
				appsInRow.sort(function(a, b) {
				  return parseInt(a.style.top) - parseInt(b.style.top);
				});
			else
				appsInRow.sort(function(a, b) {
				  return parseInt(a.style.left) - parseInt(b.style.left);
				});
		}
			
		
		for(let i=0;i<count;i++){
			if(sideWays)
				appPoints[i]={x:rect.left+width/2,y:64+rect.top+(i)*ratio};
			else
				appPoints[i]={x:64+rect.left+(i)*ratio,y:rect.top+height/2};

			
			if(targetMove && targetMove==appsInRow[i])
				targetPoint=appPoints[i]

			if(notate){
				apps[i].spot=i;
				appPoints[i].app=appsInRow[i]
			}
			_moveEle(appsInRow[i],appPoints[i].x,appPoints[i].y)	
		}
		if(barLineFactor==-1){
			let handle=barHandle.getBoundingClientRect();
			if(sideWays){
				let xx=handle.left+handle.width/2
				drawSimpleBarLine({x:xx,y:handle.top},{x:xx,y:handle.bottom})
			}else{
				let yy=handle.top+handle.height/2
				drawSimpleBarLine({x:handle.left,y:yy},{x:handle.right,y:yy})
			}
			
		}
	}
	function animate(){
		if(barLineFactor>-1){
			if(barLineFactor<4){
				if(barLineFactor){
					let target={};
					let rect=barHandle.getBoundingClientRect();
					let mid={x:rect.width/2,y:rect.height/2}

					if(barPos==0 || barPos==2){
						switch(barLineFactor){
							case 3: target={x:rect.left+mid.x,y:rect.top};break;
							case 2: target={x:rect.left+mid.x,y:rect.top+mid.y};break;
							default:target={x:rect.left+mid.x,y:rect.bottom}
						}
					}else{
						switch(barLineFactor){
							case 3: target={x:rect.left,y:rect.top+mid.y};break;
							case 2: target={x:rect.left+mid.x,y:rect.top+mid.y};break;
							default:target={x:rect.right,y:rect.top+mid.y}
						}
					}
					
					let dx=mouseObj.x-target.x;
					let dy=mouseObj.y-target.y;
					let dr=Math.sqrt(dx*dx +dy*dy)
					mouseObj.x-=dx/2
					mouseObj.y-=dy/2
					if(dr<1 && barLineFactor<4 )
						barLineFactor++;
				}

			
				let diff={x:mouseObj.x-points[0].x,y:mouseObj.y-points[0].y}
				let dr=Math.sqrt(diff.x*diff.x + diff.y*diff.y)

				if(dr>40){
					let nextVector;
					if(barLineFactor>1){ //straight to next point
						nextVector={x:mouseObj.x,y:mouseObj.y};
					}else{ //wiggle the line
						nextVector={x:mouseObj.x-(tick?1:-1)*20*diff.y/dr,y:mouseObj.y+(tick?1:-1)*20*diff.x/dr};
					}
					
					let dir=Math.abs(diff.x)>Math.abs(diff.y);
					let pos=dir?diff.x>0:diff.y>0
					tick=!tick

					drawBarLine(nextVector);
				}
			}else{
				if(barLineFactor%5==1){
					
					let target=points.shift();
					console.log('chop off points '+points.length)
					if(points.length<=3){
						barLineFactor=-1;
						barCalculate();
					}else{
						drawBarLine(target)
					}
					
				}
				if(barLineFactor!=-1)
					barLineFactor++;

			}
		}
		if(targetMove)
			moveFactor++;

		requestAnimationFrame(animate);
	}
	function drawBarLine(nextVector){
		let st="M"+mouseObj.x+" "+mouseObj.y;
		let last={x:nextVector.x,y:nextVector.y};
		for(let i=0;i<points.length;i++){
			let halfy=(points[i].y-last.y)/2
			let halfx=(points[i].x-last.x)/2
			let midx=last.x+halfx;
			let midy=last.y+halfy;
			st+="Q"+last.x+" "+last.y+" "+midx+" "+midy//+points[i].x+" "+points[i].y

			let prev={x:points[i].x,y:points[i].y};
			points[i]={x:last.x,y:last.y};
			last=prev;
		}
		path.setAttribute('d',st)
	}
	function drawSimpleBarLine(one,two){
		let st="M"+one.x+' '+one.y+"L"+two.x+' '+two.y;
		path.setAttribute('d',st);
	}
	
	function mousemove(ev){
		barMoveHandler(ev);
		if(targetMove){
			moveFactor++;
			targetMove.pos={x:ev.clientX+targetMove.offset.x,y:ev.clientY+targetMove.offset.y}
			/*let d={x:targetMove.origin.x-targetMove.pos.x,y:targetMove.origin.y-targetMove.pos.y}
			let dr=Math.sqrt(d.x*d.x +d.y*d.y);
			if(dr<80){
				targetMove.pos={x:targetMove.origin.x-d.x/3,y:targetMove.origin.y-d.y/3}
				if(targetMove.moving){
					targetMove.moving=undefined
					//targetMove.classList.remove('appMove')
				}
			}else{
				if(!targetMove.moving){
					targetMove.moving=true;
					//targetMove.classList.add('appMove')
				}
			}*/
			
			if(ev.clientY>barBox.top && ev.clientY<barBox.bottom && ev.clientX>barBox.left && ev.clientX<barBox.right){ //dev temp
					let point=targetPoint;
					let d={x:point.x-targetMove.pos.x,y:point.y-targetMove.pos.y}
					targetMove.pos={x:point.x-d.x/3,y:point.y-d.y/3}
					if(targetMove.moving){ //called once per state change
						targetMove.moving=undefined;
						targetMove.spot=0;
						barCalculate();
					}

					apps.forEach(app=>{
							if(app==targetMove || app.spot==-1){

							}else{
								if(app.pos.x>targetMove.pos.x){
									_moveEle(app,32+app.pos.x,app.pos.y,true)
								}else{
									_moveEle(app,-32+app.pos.x,app.pos.y,true)
								}
							}
						})						
				}else{
					if(!targetMove.moving){ //called once per state change
						targetMove.moving=true;
						targetMove.spot=-1;
						
						barCalculate()
					}
					
				}
			//appPoints.forEach(pointCheck)

			targetMove.style.left=targetMove.pos.x+'px'
			targetMove.style.top=targetMove.pos.y+'px'
		}else if(barLineFactor==0){
			if(count>2){
				count=0;
				mouseObj={x:ev.clientX,y:ev.clientY}

			}count++
		}
	}
	function barMoveHandler(ev){
		if(barMove){
			let xx=ev.clientX;
			let yy=ev.clientY;
			let dx=xx-window.innerWidth/2;
			let dy=yy-window.innerHeight/2;
			let r=Math.atan2(dy,dx)/Math.PI;
			let ar=Math.abs(r)
			if(ar<0.25){ //right
				//bar.style.transform='translate(-50%,-50%) rotate(90deg)'
				if(barPos!=2){
					barPos=2;

					bar.style.left=window.innerWidth-64+'px';bar.style.top='50%';//window.innerHeight/2;
					barCalculate();
					barHandle.style.transform='translate(-200%,-50%)'
					barHandle.style.width='64px';barHandle.style.height='80%';
				}
			}else if(ar<0.75){ //top or bottom
				if(r<0){ //botttom
					if(barPos!=1){
						barPos=1;
						barHandle.style.transform='translate(-50%,100%)'
						bar.style.left='50%';bar.style.top='64px' //-196+window.innerWidth/2
					}
				}else{ //top
					if(barPos!=3){
						barPos=3
						barHandle.style.transform='translate(-50%,-200%)'
						bar.style.left='50%';bar.style.top=(window.innerHeight-64)+'px'; //-196+window.innerWidth/2
					}
				}
				barCalculate();
				barHandle.style.height='64px';barHandle.style.width='80%';
			}else{ //left
				if(barPos!=0){
					barPos=0;
					barHandle.style.transform='translate(100%,-50%)'
					bar.style.left='64px';bar.style.top='50%'
					barCalculate()
					barHandle.style.width='64px'
					barHandle.style.height='80%'
				}
			}



/*
				if(window.innerWidth>window.innerHeight){ //landscape
					let half=(window.innerWidth - window.innerHeight)/2
					if(xx<half){ //left
						bar.style.transform='rotate(90deg)'
						barHandle.style.transform='translate(-50%,-200%)'
					}else if(xx>window.innerWidth-half){ //right
						bar.style.transform='rotate(90deg)'
						barHandle.style.transform='translate(-50%,100%)'
					}else{
						bar.style.transform='rotate(0deg)'
						if(yy>window.innerHeight/2){
							barHandle.style.transform='translate(-50%,-200%)'
						}else{
							barHandle.style.transform='translate(-50%,100%)'
						}
					}
				}else{ //portrait
					let half=(window.innerHeight - window.innerWidth)/2
					if(yy<half){ //top
						bar.style.transform='rotate(0deg)'
						barHandle.style.transform='translate(-50%,-200%)'
					}else if(yy>window.innerHeight-half){ //bottom
						bar.style.transform='rotate(0deg)'
						barHandle.style.transform='translate(-50%,100%)'
					}else{
						bar.style.transform='rotate(90deg)'
						if(xx>window.innerWidth/2){
							barHandle.style.transform='translate(-50%,-200%)'
						}else{
							barHandle.style.transform='translate(-50%,100%)'
						}
					}
				}*/
				
				
				
		}
	}
	/*
	function pointCheck(point,index){
		let d={x:point.x-targetMove.pos.x,y:point.y-targetMove.pos.y}
				let dr=Math.sqrt(d.x*d.x +d.y*d.y);


				if(dr<40){
					targetMove.pos={x:point.x-d.x/3,y:point.y-d.y/3}
					if(targetMove.moving){ //called once per state change
						targetMove.moving=undefined
						//targetMove.classList.remove('appMove')
					}
					if(point.app==targetMove){

					}else{ //switcheroo the app icons
						//let oldPoint=appPoints[targetMove.spot];
						let swapApp=point.app;
						targetMove.spot=index;
						apps.forEach(app=>{
							if(app==targetMove){

							}else{
								if(app.pos.x>targetMove.pos.x){
									_moveEle(app,64+app.pos.x,app.pos.y,true)
								}else{
									_moveEle(app,-64+app.pos.x,app.pos.y,true)
								}
							}

						})


					}
				}else{
					if(!targetMove.moving){ //called once per state change
						targetMove.moving=true;
						//targetMove.classList.add('appMove')

					}
				}
	}*/

	function appMouseDown(app,ev){
		targetMove=app;
		app.pos={x:parseInt(app.style.left),y:parseInt(app.style.top)}
		app.origin={x:app.pos.x,y:app.pos.y}
		app.offset={x:app.pos.x-ev.clientX,y:app.pos.y-ev.clientY}
		app.classList.add('appMove')
		app.moving=undefined;
		moveFactor=0;
	}

	function winMouseUp(ev){
		if(barMove){
			barMove=false;
			barLineFactor=1;
		}

		if(targetMove){
			targetMove.classList.remove('appMove')
			if(moveFactor<20){
				if(focused && focused==targetMove){
						targetMove.classList.remove('appMax')
						focused=undefined;
						targetMove.style.zIndex=1;
				}else{
					targetMove.classList.add('appMax')
					if(focused){
						focused.classList.remove('appMax')
						focused.style.zIndex=1;
					}
					targetMove.style.zIndex=0;
					focused=targetMove;
				}
			}else{
				barCalculate();

				console.log('fix bar also' )
			}
		}else{
				barCalculate();
				console.log('fix bar')
			}
		targetMove=undefined;

	}

	function boundaryCheck() {
		apps.forEach(app=>{
			if(!app.focused){
				let rect=app.getBoundingClientRect();

				let x=rect.left;
				let y=rect.top;
				let w2=(rect.right-rect.left)/2;
				let h2=(rect.bottom-rect.top)/2

				if(x<0 ){
					app.style.left=w2+'px'
				}else if(x> window.innerWidth-w2*2){
					app.style.left=window.innerWidth-w2+'px'
				}
				if(y<0 ){
					app.style.top=h2+'px'
				}else if(y> window.innerHeight-h2*2){
					app.style.top=window.innerHeight-h2+'px'
				}

			}
			
		})
	}
	function _moveEle(ele,x,y,bool){
		if(!bool)
			ele.pos={x:x,y:y}
		ele.style.left=x+'px'
		ele.style.top=y+'px'
	}



	/**
	OlD curve code

	

				let last={x:mouseObj.x,y:mouseObj.y,dir:dir,pos:pos};
				let lastMode=-1;
				for(let i=0;i<points.length;i++){
					//st+="M"+last.x+" "+last.y
					let halfy=(points[i].y-last.y)/2
					let halfx=(points[i].x-last.x)/2
					if(lastMode==-1){
						lastMode=(Math.abs(halfx)<Math.abs(halfy))?1:0
					}
					if(points[i].dir==last.dir){
						if(!last.dir){ //up down dir //points[i].dir
							st+="Q"+last.x+" "+(last.y+halfy)+" "+(last.x+halfx)+" "+(last.y+halfy);
							st+="Q"+points[i].x+" "+(last.y+halfy)+" "+points[i].x+" "+points[i].y;
						}else{ //left right dir
							st+="Q"+(last.x+halfx)+" "+last.y+" "+(last.x+halfx)+" "+(last.y+halfy);
							st+="Q"+(last.x+halfx)+" "+points[i].y+" "+points[i].x+" "+points[i].y;
							
						}
					}else{ //curve in then
						if(last.dir){ // true is x left right
							if((halfy>0)!=last.pos){
								st+="C"+(last.x)+" "+(last.y-halfy)+" "+(last.x+halfx)+" "+(last.y-halfy)+" "+(last.x+halfx)+" "+(last.y+halfy);

								st+="Q"+(last.x+halfx)+" "+(last.y+halfy)+" "+points[i].x+" "+points[i].y;
														console.log('special')


							}else{
								st+="Q"+(points[i].x)+" "+last.y+" "+points[i].x+" "+points[i].y;
							}
							
						}else{
							st+="Q"+(last.x)+" "+points[i].y+" "+points[i].x+" "+points[i].y;
						}
					}
					
					

					


					let prev={x:points[i].x,y:points[i].y,dir:points[i].dir,pos:points[i].pos};
					points[i]={x:last.x,y:last.y,dir:last.dir,pos:last.pos};
					last=prev;
				}
	**/

</script>
</html>