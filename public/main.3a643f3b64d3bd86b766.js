(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"],{

/***/ "./src lazy recursive":
/*!***********************************!*\
  !*** ./src lazy namespace object ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./src lazy recursive\";\n\n//# sourceURL=webpack:///./src_lazy_namespace_object?");

/***/ }),

/***/ "./src/Main.js":
/*!*********************!*\
  !*** ./src/Main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Render_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Render.js */ \"./src/Render.js\");\n/* harmony import */ var _SceneManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SceneManager.js */ \"./src/SceneManager.js\");\n\r\n\r\n\r\nfunction init(){\r\n\t_Render_js__WEBPACK_IMPORTED_MODULE_0__[\"init\"]();\r\n\r\n\r\n\r\n\r\n\tvar toggle=false;\r\n\r\n\tvar opened=document.querySelector('#seg3');\r\n\r\n\r\n\r\n\r\n\tdocument.querySelectorAll(\".column\").forEach((c,i)=>{\r\n\t\tc.addEventListener('mouseover',ev=>{\r\n\t\t\tif(!c.children.length){\r\n\t\t\t\t/*var e = ev.toElement || ev.relatedTarget;\r\n\t\t        if (e.parentNode == this || e == this) {\r\n\t\t           return;\r\n\t\t        }*/\r\n\r\n\r\n\t\t\t\t\r\n\r\n\r\n\t\t\t\t\r\n\r\n\t\t\t\t/*if(d.reserved)\r\n\t\t\t\t\td.remove();\r\n\r\n\t\t\t\t\r\n\t\t\t\tc.appendChild(d);*/\r\n\r\n\t\t\t\t/*setTimeout(()=>{\r\n\t\t\t\t\t//d.style.opacity=1;\r\n\t\t\t\t},10);*/\r\n\r\n\t\t\t}\r\n\t\t\tif(opened!=c){\r\n\t\t\t\tlet d=_Render_js__WEBPACK_IMPORTED_MODULE_0__[\"getAlphaCanvas\"]();\r\n\t\t\t\td.style.opacity=1;\r\n\t\t\t\td.remove();\r\n\t\t\t\tlet afterImage=document.querySelector('#afterImage');\r\n\t\t\t\tafterImage.remove();\r\n\r\n\t\t\t\tc.appendChild(d);\r\n\t\t\t\t\t\r\n\t\t\t\topened.appendChild(afterImage);\r\n\t\t\t\tafterImage.style.opacity=1;\r\n\t\t\t\tsetTimeout(()=>{afterImage.style.opacity=0;},1);\r\n\t\t\t\topened.classList.remove('openedColumn');\r\n\t\t\t\t_Render_js__WEBPACK_IMPORTED_MODULE_0__[\"bufferPrint\"]();\r\n\t\t\t\topened=c;\r\n\t\t\t\t//if(i<4)\r\n\t\t\t\topened.classList.add('openedColumn');\r\n\r\n\t\t\t\t_SceneManager_js__WEBPACK_IMPORTED_MODULE_1__[\"flipScene\"](i);\r\n\r\n\t\t\t\tlet mainTitle=document.querySelector('#mainTitle');\r\n\t\t\t\tif(mainTitle)\r\n\t\t\t\t\tmainTitle.style.left=window.innerWidth*(0.38 + i*0.06)+'px' //half 76% + offset of tabs\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tc.addEventListener('mouseout',ev=>{\r\n\t\t\tif(c.children.length){\r\n\t\t\t\t//c.firstChild.style.opacity=0;\r\n\t\t\t\t//setTimeout(()=>{c.firstChild.remove()},1000)\r\n\t\t\t}\r\n\t\t})\r\n\t})\r\n\r\n}init();\n\n//# sourceURL=webpack:///./src/Main.js?");

/***/ }),

/***/ "./src/Render.js":
/*!***********************!*\
  !*** ./src/Render.js ***!
  \***********************/
/*! exports provided: init, getAlphaCanvas, getBetaCanvas, bufferPrint, loadModel, specterMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAlphaCanvas\", function() { return getAlphaCanvas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBetaCanvas\", function() { return getBetaCanvas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bufferPrint\", function() { return bufferPrint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadModel\", function() { return loadModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"specterMaterial\", function() { return specterMaterial; });\n/* harmony import */ var _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/three.module.js */ \"./src/lib/three.module.js\");\n/* harmony import */ var _lib_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/GLTFLoader.js */ \"./src/lib/GLTFLoader.js\");\n/* harmony import */ var _SceneManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SceneManager.js */ \"./src/SceneManager.js\");\n/* harmony import */ var _lib_EffectComposer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/EffectComposer.js */ \"./src/lib/EffectComposer.js\");\n/* harmony import */ var _lib_ShaderPass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/ShaderPass.js */ \"./src/lib/ShaderPass.js\");\n/* harmony import */ var _lib_LuminosityShader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/LuminosityShader.js */ \"./src/lib/LuminosityShader.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import * as Control from \"./Control.js?v=16\";\r\n//import * as World from \"./World.js?v=16\";\r\n//import {OrbitControls} from \"./lib/OrbitControls.js\";\r\n//import * as Texture from \"./Texture.js?v=16\";\r\n//import * as Stats from \"./lib/stats.js\";\r\n//import * as AssetManager from \"./AssetManager.js?v=16\";\r\n//import * as Experiment from \"./Experiment.js?v=16\";\r\n\r\n\r\nvar camera, renderer;\r\n\r\n\r\nvar docWidth,docHeight;\r\n\r\nvar loader;\r\nvar mixer;\r\n\r\nvar SHADOW_SIZE=2048;\r\nvar SIZE_DIVIDER=2;\r\n\r\nvar alphaCanvas;\r\nvar betaCanvas;\r\n\r\n\r\nvar activeCanvas;\r\n\r\nvar composer;\r\n\r\nvar specterMaterial;\r\n\r\n\r\n\r\nfunction init(){\r\n    camera = new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"]( 45, window.innerWidth / window.innerHeight, 1, 5000 );\r\n    camera.position.z = 100; //400\r\n    camera.position.y = -200; //-800\r\n    camera.up=new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0,0,1)\r\n\r\n    camera.lookAt(new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]( 0, 100, 0 ));\r\n\r\n    \r\n\r\n    alphaCanvas=document.createElement('div');\r\n    betaCanvas=document.createElement('div');\r\n    alphaCanvas.classList.add('canvasHolder');\r\n    betaCanvas.classList.add('canvasHolder');\r\n    betaCanvas.style.background='#fff5'\r\n    alphaCanvas.reserved=false;\r\n    betaCanvas.reserved=false;\r\n\r\n\r\n    renderer = new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"WebGLRenderer\"]({alpha: true, antialias:true});\r\n    renderer.shadowMap.enabled = true;\r\n    renderer.shadowMap.type = _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"PCFSoftShadowMap\"];\r\n\r\n    renderer.setClearColor(0x000000, 0);//0xb0e9fd,1);//0xb0e9fd,1)\r\n\r\n    alphaCanvas.appendChild( renderer.domElement );\r\n\r\n    loader = new _lib_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_1__[\"GLTFLoader\"]();\r\n\r\n    initCustomMaterial();\r\n\r\n    _SceneManager_js__WEBPACK_IMPORTED_MODULE_2__[\"init\"]();\r\n    activeCanvas=alphaCanvas;\r\n\r\n\r\n    window.addEventListener('resize',resizer);\r\n    resizer();\r\n\r\n\r\n    composer = new _lib_EffectComposer_js__WEBPACK_IMPORTED_MODULE_3__[\"EffectComposer\"]( renderer );\r\n    var luminosityPass = new _lib_ShaderPass_js__WEBPACK_IMPORTED_MODULE_4__[\"ShaderPass\"]( _lib_LuminosityShader_js__WEBPACK_IMPORTED_MODULE_5__[\"LuminosityShader\"] );\r\n    composer.addPass( luminosityPass );\r\n    \r\n\r\n    animate();\r\n    window.camera=camera;\r\n\r\n    \r\n}\r\nfunction getAlphaCanvas(){\r\n    return alphaCanvas;\r\n}\r\nfunction getBetaCanvas(){\r\n    return betaCanvas;\r\n}\r\n\r\nfunction loadModel(model,callback,texture,color){\r\n    loader.load(\r\n        ('./'+model),//villager22.gltf',\r\n        ( gltf ) => {\r\n            // called when the resource is loaded\r\n            //gltf.scene.scale.set(10,10,10);\r\n            let model;//=gltf.scene.children[0];\r\n            gltf.scene.rotation.x=Math.PI/2;\r\n            gltf.scene.traverse( function ( child ) {\r\n                if (child instanceof _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"]) {\r\n                    //if(child.name==\"Cube\"){\r\n                        model=child;\r\n                        //create a global var to reference later when changing textures\r\n                        //apply texture\r\n                        \r\n\r\n                        //\r\n                        \r\n\r\n                        if(!texture){\r\n                            if(color)\r\n                                child.material = new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"]({ color: color, metalness: 0, roughness: 1.0}); // \r\n                            else\r\n                                child.material = specterMaterial; //new THREE.MeshStandardMaterial({ vertexColors: THREE.VertexColors, metalness: 0, roughness: 1.0}); // \r\n                          \r\n                            child.material.needsUpdate = true;\r\n                            //child.material.skinning=true;\r\n                        }\r\n                        //child.material.morphTargets=true;\r\n\r\n                        //child.material.map.needsUpdate = true;\r\n                   // }else{\r\n\r\n                    //}\r\n                }\r\n            });\r\n            //gltf.scene.children[0].children[1].scale.set(20,20,20);\r\n\r\n            //gltf.scene.children.pop();\r\n           \r\n\r\n            //let mixer = new THREE.AnimationMixer( gltf.scene );\r\n             //model=gltf.scene.children[0]\r\n             let m2=gltf.scene.children[0];\r\n             if(model){\r\n                var animations = gltf.animations;\r\n                if ( animations && animations.length ) {\r\n\r\n                    mixer = new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"AnimationMixer\"](model);\r\n                    for ( var i = 0; i < animations.length; i ++ ) {\r\n                        var animation = animations[ i ];\r\n                        // There's .3333 seconds junk at the tail of the Monster animation that\r\n                        // keeps it from looping cleanly. Clip it at 3 seconds\r\n\r\n                        //if ( sceneInfo.animationTime ) {\r\n                        //    animation.duration = sceneInfo.animationTime;\r\n\r\n\r\n                       // }\r\n                        action = mixer.clipAction( animation );\r\n                        //action.setEffectiveTimeScale(200);\r\n                        //action.timeScale=0.002;\r\n                        action.timeScale=0.002;\r\n                        //if ( state.playAnimation ) \r\n                            action.play();\r\n                    }\r\n                }\r\n                 //mainScene.add( gltf.scene.children[0] );\r\n             }\r\n            callback(gltf.scene);\r\n        },\r\n        ( xhr ) => {\r\n            // called while loading is progressing\r\n            console.log( `${( xhr.loaded / xhr.total * 100 )}% loaded` );\r\n        },\r\n        ( error ) => {\r\n            // called when loading has errors\r\n            console.error( 'An error happened', error );\r\n        },\r\n    );\r\n}\r\n/*var toggle=false;\r\nfunction animationControl(ev){\r\n    if(action){\r\n        if(toggle){\r\n            action.reset().play();\r\n        }else{\r\n            action.halt(1000);\r\n        }\r\n        toggle=!toggle;\r\n    }\r\n}\r\n*/\r\n\r\nfunction resizer(){\r\n    docWidth=Math.floor(window.innerWidth*0.76);\r\n    docHeight=window.innerHeight;\r\n    camera.aspect=docWidth/docHeight;\r\n    camera.updateProjectionMatrix();\r\n    \r\n    renderer.setPixelRatio( window.devicePixelRatio/SIZE_DIVIDER);\r\n    renderer.setSize( docWidth, docHeight);\r\n}\r\n\r\n\r\n\r\nfunction animate(time) {\r\n    //let delta=time-prevTime;\r\n\r\n    //if(mixer)mixer.update(delta);\r\n    _SceneManager_js__WEBPACK_IMPORTED_MODULE_2__[\"animate\"]();\r\n    //\r\n    //prevTime=time;\r\n    //applyCursor();\r\n    //if(_grabImage == true){\r\n       // dumpImage(renderer.domElement.toDataURL());\r\n        //_grabImage = false;\r\n   // }\r\n   \r\n    renderer.render( _SceneManager_js__WEBPACK_IMPORTED_MODULE_2__[\"getScene\"](), camera );\r\n    //composer.render();\r\n    requestAnimationFrame( animate );\r\n}\r\nfunction dumpImage(img){\r\n    let dom=document.querySelector('#afterImage');\r\n    if(dom)\r\n        dom.setAttribute('src',img);\r\n}\r\nfunction bufferPrint(){\r\n    //_grabImage=true;\r\n    renderer.render( _SceneManager_js__WEBPACK_IMPORTED_MODULE_2__[\"getScene\"](), camera );\r\n    dumpImage(renderer.domElement.toDataURL());\r\n}\r\n\r\nvar anchors=[];\r\nfunction addAnchor(host,bubble){\r\n    let anchor={\r\n        host:host,\r\n        bubble:bubble,\r\n        x:0,\r\n        y:0,\r\n        offset:0,\r\n    }\r\n    anchors.forEach(a=>{\r\n        if(a.host==host){\r\n            a.offset-=40;\r\n        }\r\n    })\r\n    anchors.push(anchor);\r\n    console.log(anchors.length+' anchors');\r\n    updateAnchor(anchor,anchors.length-1);\r\n    return anchor;\r\n}\r\nfunction updateAnchor(anchor,index){\r\n    if(!anchor.bubble){\r\n        anchors.splice(index,1);\r\n        return false;\r\n    }\r\n    if(anchor.host){\r\n        let vector=projectVector(anchor.host);\r\n        anchor.bubble.style.left=-16+vector.x+'px';\r\n        anchor.bubble.style.top=(40+anchor.offset+vector.y)+'px';\r\n        anchor.x=vector.x;\r\n        anchor.y=vector.y;\r\n    }\r\n    \r\n}\r\nfunction roundEdge(x){\r\n    x=x%(Math.PI)\r\n    if(x<0)\r\n        x+=Math.PI*2;\r\n    \r\n    if(x>Math.PI/4){\r\n        if(x>5*Math.PI/4){\r\n            if(x<7*Math.PI/4){\r\n                return Math.PI*3/2;\r\n            }\r\n        }else{\r\n            if(x>3*Math.PI/4){\r\n                return Math.PI;\r\n            }else{\r\n                return Math.PI/2;\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nfunction preModel(){\r\n\t/*cubeGeometry = new THREE.BoxBufferGeometry( 20, 20, 20 );\r\n   \tcubeMaterial = new THREE.MeshBasicMaterial( { color:0xff8833 } ); //map: texture\r\n    circleGeometry=new THREE.CircleGeometry( 5, 8 );\r\n    let pointerGeom = new THREE.CircleGeometry( 6, 16 );\r\n    pointerMat = new THREE.MeshBasicMaterial( { color:0x4AE13A } );\r\n    pointerMatOn = new THREE.MeshBasicMaterial( { color:0xEBEE00 } );\r\n    pointer = new THREE.Mesh(pointerGeom,pointerMat);\r\n    pointer.position.z=1;\r\n    mainScene.add(pointer);\r\n\r\n\r\n    var length = 12, width = 8;\r\n\r\nvar shape = new THREE.Shape();\r\n\r\nlet cir=200;\r\nshape.moveTo( 0,-cir );\r\n\r\n\r\nfor(let i=0;i<45;i++){\r\n    let r=Math.PI*i/18.0;\r\n    let x=Math.cos(r)*cir;\r\n    let y=Math.sin(r)*cir;\r\n    x*=(1+Math.random()/2.0);\r\n    y*=(1+Math.random()/2.0);\r\n    shape.lineTo(x,y)\r\n}\r\n\r\nvar extrudeSettings = {\r\n    steps: 2,\r\n    depth: 16,\r\n    bevelEnabled: true,\r\n    bevelThickness: 2,\r\n    bevelSize: 8,\r\n    bevelOffset: 2,\r\n    bevelSegments: 1\r\n};\r\n\r\nvar geometry = new THREE.ExtrudeBufferGeometry( shape, extrudeSettings );\r\nvar material = new THREE.MeshStandardMaterial( { color: 0xA1D100,roughness: 1.0,metalness: 0.0 } );\r\nvar mesh = new THREE.Mesh( geometry, material ) ;\r\n\r\nmesh.position.z-=18;\r\n\r\nmesh.receiveShadow=true;\r\ncurrentScene.add( mesh );\r\n\r\n\r\nambientLight = new THREE.AmbientLight( 0x404040 ); // soft white light\r\ncurrentScene.add( ambientLight );\r\n\r\n//var directionalLight = new THREE.PointLight( 0xffffff, 1,100 );\r\nsunLight = new THREE.DirectionalLight( 0xffffff, 0.5 ); //DirectionalLight\r\nsunLight.position.set(0,160,200);\r\nsunLight.castShadow = true;\r\ncurrentScene.add( sunLight );\r\n\r\nsunLight.shadow.mapSize.width = SHADOW_SIZE;  // default\r\nsunLight.shadow.mapSize.height = SHADOW_SIZE; // default\r\nsunLight.shadow.camera.near = 10;    // default\r\nsunLight.shadow.camera.far = 500;     // default\r\nconst d1 = 300;\r\n\r\nsunLight.shadow.camera.left = - d1;\r\nsunLight.shadow.camera.right = d1;\r\nsunLight.shadow.camera.top = d1;\r\nsunLight.shadow.camera.bottom = - d1;\r\n\r\nsunLight.shadow.radius = 2.2;\r\n\r\nsunLight2=sunLight.clone();\r\nsunLight2.shadow.mapSize.width = 256;  // default\r\nsunLight2.shadow.mapSize.height = 256; // default\r\nsunLight2.shadow.radius = 0;\r\nsunLight2.visible=false;\r\ncurrentScene.add(sunLight2);\r\n\r\nvar helper = new THREE.CameraHelper( sunLight.shadow.camera );\r\ncurrentScene.add( helper );\r\n*/\r\n\r\n}\r\n\r\nfunction syncModel(index,obj){\r\n\tlet m=modelsIndexed[index];\r\n\tm.position.x=obj.x;\r\n\tm.position.y=obj.y;\r\n\tm.position.z=obj.z;\r\n}\r\nfunction createModel(index){\r\n\tlet model = new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"]( cubeGeometry, cubeMaterial );\r\n\tmodelsIndexed[index]=model;\r\n\treturn model;\r\n}\r\n/*\r\nfunction cubit(w,h,d,x,y,z,color,layer){\r\n\tlet geom = new THREE.BoxBufferGeometry( w, h, d );\r\n    let mat;\r\n    if(color)\r\n        mat=new THREE.MeshStandardMaterial( { color: parseInt(color)} );\r\n    \r\n\tlet model = new THREE.Mesh( geom,mat);\r\n\tmodel.position.x=x;\r\n\tmodel.position.y=y;\r\n\tmodel.position.z=z;\r\n    model.castShadow=true;\r\n    model.receiveShadow=true;\r\n    if(layer!=undefined && scenes[layer]){\r\n        scenes[layer].add(model);\r\n    }else\r\n\t   scenes[0].add(model);\r\n    return model;\r\n}*/\r\nfunction getRandomColor() {\r\n  var letters = '0123456789ABCDEF';\r\n  var color = Math.random()>0.5?0x66B136:0x76610E;\r\n  return parseInt(color);\r\n}\r\n\r\nfunction applyCursor(){\r\n\tif(Control.down()){\r\n        pointer.material=pointerMatOn;\r\n    }else\r\n        pointer.material=pointerMat;\r\n\t\tvar vector = new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();     \r\n\t    vector.set(( Control.screenX() / window.innerWidth ) * 2 - 1, - ( Control.screenY() / window.innerHeight ) * 2 + 1,0.5 );\r\n\t    vector.unproject(camera)\r\n\t    var dir = vector.sub( camera.position ).normalize();\r\n\t    var distance = - camera.position.z / dir.z;\r\n\t    var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );\r\n\t    \r\n\t    pointer.position.x =pos.x;\r\n\t    pointer.position.y =pos.y\r\n\t    Control.setVector(pointer.position);\r\n\t\r\n}\r\nfunction projectVector(object){\r\n\r\n    var width = docWidth, height = docHeight;\r\n    var widthHalf = width / 2, heightHalf = height / 2;\r\n\r\n    let vector=object.position.clone();\r\n    vector.z+=30\r\n    //vector.applyMatrix4(object.matrixWorld);\r\n    vector.project(camera)\r\n\r\n    //var projector = new THREE.Projector();\r\n    //projector.projectVector( vector.setFromMatrixPosition( object.matrixWorld ), camera );\r\n\r\n    vector.x = ( vector.x * widthHalf ) + widthHalf;\r\n    vector.y = - ( vector.y * heightHalf ) + heightHalf;\r\n    return vector;\r\n\r\n}\r\n\r\n\r\nvar specterMaterial\r\nfunction initCustomMaterial(){\r\n\r\n    var meshphysical_frag = `\r\n    #define STANDARD\r\n#ifdef PHYSICAL\r\n    #define REFLECTIVITY\r\n    #define CLEARCOAT\r\n    #define TRANSPARENCY\r\n#endif\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform float opacity;\r\n#ifdef TRANSPARENCY\r\n    uniform float transparency;\r\n#endif\r\n#ifdef REFLECTIVITY\r\n    uniform float reflectivity;\r\n#endif\r\n#ifdef CLEARCOAT\r\n    uniform float clearcoat;\r\n    uniform float clearcoatRoughness;\r\n#endif\r\n#ifdef USE_SHEEN\r\n    uniform vec3 sheen;\r\n#endif\r\nvarying vec3 vViewPosition;\r\n#ifndef FLAT_SHADED\r\n    varying vec3 vNormal;\r\n    #ifdef USE_TANGENT\r\n        varying vec3 vTangent;\r\n        varying vec3 vBitangent;\r\n    #endif\r\n#endif\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <bsdfs>\r\n#include <cube_uv_reflection_fragment>\r\n#include <envmap_common_pars_fragment>\r\n#include <envmap_physical_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <lights_pars_begin>\r\n#include <lights_physical_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n\r\n#include <roughnessmap_pars_fragment>\r\n#include <metalnessmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\nvoid main() {\r\n    #include <clipping_planes_fragment>\r\n    vec4 diffuseColor = vec4( diffuse, opacity );\r\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n    vec3 totalEmissiveRadiance = emissive;\r\n    #include <logdepthbuf_fragment>\r\n    #include <map_fragment>\r\n    #include <color_fragment>\r\n    #include <alphamap_fragment>\r\n    #include <alphatest_fragment>\r\n    #include <roughnessmap_fragment>\r\n    #include <metalnessmap_fragment>\r\n    #include <normal_fragment_begin>\r\n    #include <normal_fragment_maps>\r\n    #include <clearcoat_normal_fragment_begin>\r\n    #include <clearcoat_normal_fragment_maps>\r\n    #include <emissivemap_fragment>\r\n    #include <lights_physical_fragment>\r\n    #include <lights_fragment_begin>\r\n    #include <lights_fragment_maps>\r\n    #include <lights_fragment_end>\r\n    #include <aomap_fragment>\r\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n    #ifdef TRANSPARENCY\r\n        diffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\r\n    #endif\r\n    gl_FragColor = vec4( outgoingLight,1.-(((0.2125 * outgoingLight.r) + (0.7154 * outgoingLight.g) + (0.0721 * outgoingLight.b)) ) );\r\n    #include <tonemapping_fragment>\r\n    #include <encodings_fragment>\r\n    #include <fog_fragment>\r\n    #include <premultiplied_alpha_fragment>\r\n    #include <dithering_fragment>\r\n}`\r\n\r\n//gl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\r\n/*\r\n#ifdef USE_COLOR\r\n            if(vColor==vec3(0,0,1))\r\n                diffuseColor.rgb *= vec3(1,0,0);\r\n            else\r\n                diffuseColor.rgb *= vColor;\r\n    #endif*/\r\n\r\n    //    #include <color_vertex>\r\n\r\n    var meshphysical_vert = `#define STANDARD\r\nvarying vec3 vViewPosition;\r\n#ifndef FLAT_SHADED\r\n    varying vec3 vNormal;\r\n    #ifdef USE_TANGENT\r\n        varying vec3 vTangent;\r\n        varying vec3 vBitangent;\r\n    #endif\r\n#endif\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nuniform vec3 shirt;\r\nuniform vec3 wind;\r\n\r\nvoid main() {\r\n    #include <uv_vertex>\r\n    #include <uv2_vertex>\r\n    #ifdef USE_COLOR\r\n        if(color==vec3(0,0,1))\r\n            vColor.xyz = shirt;\r\n        else\r\n            vColor.xyz = color.xyz;\r\n        \r\n    #endif\r\n    #include <beginnormal_vertex>\r\n    #include <morphnormal_vertex>\r\n    #include <skinbase_vertex>\r\n    #include <skinnormal_vertex>\r\n    #include <defaultnormal_vertex>\r\n#ifndef FLAT_SHADED\r\n    vNormal = normalize( transformedNormal );\r\n    #ifdef USE_TANGENT\r\n        vTangent = normalize( transformedTangent );\r\n        vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\r\n    #endif\r\n#endif\r\n    #include <begin_vertex>\r\n    #include <morphtarget_vertex>\r\n    #include <skinning_vertex>\r\n    #include <displacementmap_vertex>\r\n\r\n    \r\n        if(color==vec3(1,0,0)){\r\n            float val=max(0.0, 1.0976 - transformed.z);\r\n            transformed.xyz+=val*wind;\r\n            transformed.y*=1.0+sin((wind.z+transformed.z)*4.0)/2.0;\r\n\r\n        }\r\n    \r\n\r\n    #include <project_vertex>\r\n    #include <logdepthbuf_vertex>\r\n    #include <clipping_planes_vertex>\r\n    vViewPosition = - mvPosition.xyz;\r\n    #include <worldpos_vertex>\r\n    #include <shadowmap_vertex>\r\n    #include <fog_vertex>\r\n}`\r\n\r\n    var uniforms = _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"UniformsUtils\"].merge(\r\n       [_lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"ShaderLib\"].standard.uniforms,\r\n       //{shirt: {value:new THREE.Vector3(0,1,0)},\r\n        //wind: {value:new THREE.Vector3(0,0,0)}}\r\n        ]\r\n    );\r\n\r\n    /*specterMaterial =  new THREE.ShaderMaterial({\r\n    uniforms: uniforms,\r\n    fragmentShader: fragmentShader(),\r\n    vertexShader: vertexShader(),\r\n  })**/\r\n\r\n\r\n    specterMaterial=new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"ShaderMaterial\"]( {\r\n        uniforms: uniforms,\r\n        derivatives: false,\r\n        lights: true,\r\n        vertexColors: true,\r\n        vertexShader: meshphysical_vert,\r\n        fragmentShader: meshphysical_frag,\r\n        roughness: 0.0,\r\n        metalness: 1.0,\r\n        //vertexShader: THREE.ShaderChunk.cube_vert,\r\n        //fragmentShader: THREE.ShaderChunk.cube_frag\r\n    });\r\n\r\n}\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./src/Render.js?");

/***/ }),

/***/ "./src/SceneManager.js":
/*!*****************************!*\
  !*** ./src/SceneManager.js ***!
  \*****************************/
/*! exports provided: init, animate, flipScene, getScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"init\", function() { return init; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"animate\", function() { return animate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"flipScene\", function() { return flipScene; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScene\", function() { return getScene; });\n/* harmony import */ var _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/three.module.js */ \"./src/lib/three.module.js\");\n/* harmony import */ var _Render_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Render.js */ \"./src/Render.js\");\n\r\n\r\n\r\n\r\nvar emptyScene;\r\nvar scenes;\r\nvar animators = [];\r\n\r\nvar loadTest = false;\r\n\r\n\r\nvar data = [\r\n    [ /* webpackChunkName: \"App1SkyIsland\" */ './App1SkyIsland', 'Sky Island'],\r\n    [ /* webpackChunkName: \"App2Punk\" */ './App2Punk', 'Punk App']\r\n]\r\n\r\nfunction init() {\r\n    emptyScene = new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"]();\r\n    scenes = [];\r\n\r\n    let cubeGeometry = new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"BoxBufferGeometry\"](20, 20, 20);\r\n    let cubeMaterial = new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"MeshStandardMaterial\"]({ color: 0xff8833 }); //map: texture\r\n    for(let i = 2; i < 5; i++) {\r\n        scenes[i] = new _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"]();\r\n    }\r\n\r\n\r\n    // import(/* webpackChunkName: \"App1SkyIsland\" */ './App1SkyIsland').then(module => {\r\n    //     scenes[0]=module.init('Sky Island',Render,THREE);\r\n    // }); \r\n\r\n    // import(/* webpackChunkName: \"App2Punk\" */ './App2Punk').then(module => {\r\n    //     scenes[1]=module.init('Punk App',Render,THREE);\r\n    // });\r\n    //   }\r\n    // })\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n      var geometry = new THREE.SphereGeometry( 5, 32, 32 );\r\n      var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );\r\n      var sphere = new THREE.Mesh( geometry, material );\r\n\r\n      sphere.position.set(0,0,-30);\r\n      cubes.push(sphere);\r\n      scenes[2].add(sphere);\r\n\r\n\r\n      var geo = new THREE.OctahedronGeometry( 30, 1 );\r\n      var mat = new THREE.MeshBasicMaterial( {color: 0xC92DD1} ); \r\n      var octa= new THREE.Mesh( geo, mat );\r\n      octa.position.set(0,0,20);\r\n      cubes.push(octa);\r\n      scenes[3].add(octa);*/\r\n\r\n\r\n}\r\n\r\n\r\n\r\nfunction animate() {\r\n    if(activeScene == 0) {\r\n\r\n    } else if(activeScene == 1) {\r\n\r\n    }\r\n}\r\n\r\nfunction flipScene(i) {\r\n    activeScene = i;\r\n}\r\nvar activeScene = 0;\r\n\r\nfunction getScene() {\r\n    let index = activeScene;\r\n    let scene = scenes[index];\r\n    if(scene == undefined) {\r\n        scene = emptyScene\r\n        scenes[index] = 'pend';\r\n\r\n        __webpack_require__(\"./src lazy recursive\")(data[index][0]).then(module => {\r\n            scenes[index] = module.init(data[index][1], _Render_js__WEBPACK_IMPORTED_MODULE_1__, _lib_three_module_js__WEBPACK_IMPORTED_MODULE_0__);\r\n        })\r\n    } else if(scene == 'pend') {\r\n        scene = emptyScene;\r\n    }\r\n    return scene;\r\n}\r\n\r\n\n\n//# sourceURL=webpack:///./src/SceneManager.js?");

/***/ })

},[["./src/Main.js","runtime","libs"]]]);